{
  "version": 3,
  "sources": ["../../../../src/lib/shapes/arrow/arrowLabel.ts"],
  "sourcesContent": ["import {\n\tArc2d,\n\tBox,\n\tCircle2d,\n\tEdge2d,\n\tEditor,\n\tGeometry2d,\n\tPolygon2d,\n\tTLArrowShape,\n\tVec,\n\tVecLike,\n\tangleDistance,\n\tclamp,\n\tgetPointOnCircle,\n\tintersectCirclePolygon,\n\tintersectLineSegmentPolygon,\n} from '@tldraw/editor'\nimport {\n\tARROW_LABEL_FONT_SIZES,\n\tARROW_LABEL_PADDING,\n\tFONT_FAMILIES,\n\tLABEL_TO_ARROW_PADDING,\n\tSTROKE_SIZES,\n\tTEXT_PROPS,\n} from '../shared/default-shape-constants'\nimport { TLArrowInfo } from './arrow-types'\nimport { getArrowInfo } from './shared'\n\nconst labelSizeCache = new WeakMap<TLArrowShape, Vec>()\n\nfunction getArrowLabelSize(editor: Editor, shape: TLArrowShape) {\n\tconst cachedSize = labelSizeCache.get(shape)\n\tif (cachedSize) return cachedSize\n\n\tconst info = getArrowInfo(editor, shape)!\n\tlet width = 0\n\tlet height = 0\n\n\tconst bodyGeom = info.isStraight\n\t\t? new Edge2d({\n\t\t\t\tstart: Vec.From(info.start.point),\n\t\t\t\tend: Vec.From(info.end.point),\n\t\t\t})\n\t\t: new Arc2d({\n\t\t\t\tcenter: Vec.Cast(info.handleArc.center),\n\t\t\t\tstart: Vec.Cast(info.start.point),\n\t\t\t\tend: Vec.Cast(info.end.point),\n\t\t\t\tsweepFlag: info.bodyArc.sweepFlag,\n\t\t\t\tlargeArcFlag: info.bodyArc.largeArcFlag,\n\t\t\t})\n\n\tif (shape.props.text.trim()) {\n\t\tconst bodyBounds = bodyGeom.bounds\n\n\t\tconst fontSize = getArrowLabelFontSize(shape)\n\n\t\tconst { w, h } = editor.textMeasure.measureText(shape.props.text, {\n\t\t\t...TEXT_PROPS,\n\t\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\t\tfontSize,\n\t\t\tmaxWidth: null,\n\t\t})\n\n\t\twidth = w\n\t\theight = h\n\n\t\tif (bodyBounds.width > bodyBounds.height) {\n\t\t\twidth = Math.max(Math.min(w, 64), Math.min(bodyBounds.width - 64, w))\n\n\t\t\tconst { w: squishedWidth, h: squishedHeight } = editor.textMeasure.measureText(\n\t\t\t\tshape.props.text,\n\t\t\t\t{\n\t\t\t\t\t...TEXT_PROPS,\n\t\t\t\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\t\t\t\tfontSize,\n\t\t\t\t\tmaxWidth: width,\n\t\t\t\t}\n\t\t\t)\n\n\t\t\twidth = squishedWidth\n\t\t\theight = squishedHeight\n\t\t}\n\n\t\tif (width > 16 * fontSize) {\n\t\t\twidth = 16 * fontSize\n\n\t\t\tconst { w: squishedWidth, h: squishedHeight } = editor.textMeasure.measureText(\n\t\t\t\tshape.props.text,\n\t\t\t\t{\n\t\t\t\t\t...TEXT_PROPS,\n\t\t\t\t\tfontFamily: FONT_FAMILIES[shape.props.font],\n\t\t\t\t\tfontSize,\n\t\t\t\t\tmaxWidth: width,\n\t\t\t\t}\n\t\t\t)\n\n\t\t\twidth = squishedWidth\n\t\t\theight = squishedHeight\n\t\t}\n\t}\n\n\tconst size = new Vec(width, height).addScalar(ARROW_LABEL_PADDING * 2 * shape.props.scale)\n\tlabelSizeCache.set(shape, size)\n\treturn size\n}\n\nfunction getLabelToArrowPadding(shape: TLArrowShape) {\n\tconst strokeWidth = STROKE_SIZES[shape.props.size]\n\tconst labelToArrowPadding =\n\t\t(LABEL_TO_ARROW_PADDING +\n\t\t\t(strokeWidth - STROKE_SIZES.s) * 2 +\n\t\t\t(strokeWidth === STROKE_SIZES.xl ? 20 : 0)) *\n\t\tshape.props.scale\n\n\treturn labelToArrowPadding\n}\n\n/**\n * Return the range of possible label positions for a straight arrow. The full possible range is 0\n * to 1, but as the label itself takes up space the usable range is smaller.\n */\nfunction getStraightArrowLabelRange(\n\teditor: Editor,\n\tshape: TLArrowShape,\n\tinfo: Extract<TLArrowInfo, { isStraight: true }>\n): { start: number; end: number } {\n\tconst labelSize = getArrowLabelSize(editor, shape)\n\tconst labelToArrowPadding = getLabelToArrowPadding(shape)\n\n\t// take the start and end points of the arrow, and nudge them in a bit to give some spare space:\n\tconst startOffset = Vec.Nudge(info.start.point, info.end.point, labelToArrowPadding)\n\tconst endOffset = Vec.Nudge(info.end.point, info.start.point, labelToArrowPadding)\n\n\t// assuming we just stick the label in the middle of the shape, where does the arrow intersect the label?\n\tconst intersectionPoints = intersectLineSegmentPolygon(\n\t\tstartOffset,\n\t\tendOffset,\n\t\tBox.FromCenter(info.middle, labelSize).corners\n\t)\n\tif (!intersectionPoints || intersectionPoints.length !== 2) {\n\t\treturn { start: 0.5, end: 0.5 }\n\t}\n\n\t// there should be two intersection points - one near the start, and one near the end\n\tlet [startIntersect, endIntersect] = intersectionPoints\n\tif (Vec.Dist2(startIntersect, startOffset) > Vec.Dist2(endIntersect, startOffset)) {\n\t\t;[endIntersect, startIntersect] = intersectionPoints\n\t}\n\n\t// take our nudged start and end points and scooch them in even further to give us the possible\n\t// range for the position of the _center_ of the label\n\tconst startConstrained = startOffset.add(Vec.Sub(info.middle, startIntersect))\n\tconst endConstrained = endOffset.add(Vec.Sub(info.middle, endIntersect))\n\n\t// now we can work out the range of possible label positions\n\tconst start = Vec.Dist(info.start.point, startConstrained) / info.length\n\tconst end = Vec.Dist(info.start.point, endConstrained) / info.length\n\treturn { start, end }\n}\n\n/**\n * Return the range of possible label positions for a curved arrow. The full possible range is 0\n * to 1, but as the label itself takes up space the usable range is smaller.\n */\nfunction getCurvedArrowLabelRange(\n\teditor: Editor,\n\tshape: TLArrowShape,\n\tinfo: Extract<TLArrowInfo, { isStraight: false }>\n): { start: number; end: number; dbg?: Geometry2d[] } {\n\tconst labelSize = getArrowLabelSize(editor, shape)\n\tconst labelToArrowPadding = getLabelToArrowPadding(shape)\n\tconst direction = Math.sign(shape.props.bend)\n\n\t// take the start and end points of the arrow, and nudge them in a bit to give some spare space:\n\tconst labelToArrowPaddingRad = (labelToArrowPadding / info.handleArc.radius) * direction\n\tconst startOffsetAngle = Vec.Angle(info.bodyArc.center, info.start.point) - labelToArrowPaddingRad\n\tconst endOffsetAngle = Vec.Angle(info.bodyArc.center, info.end.point) + labelToArrowPaddingRad\n\tconst startOffset = getPointOnCircle(info.bodyArc.center, info.bodyArc.radius, startOffsetAngle)\n\tconst endOffset = getPointOnCircle(info.bodyArc.center, info.bodyArc.radius, endOffsetAngle)\n\n\tconst dbg: Geometry2d[] = []\n\n\t// unlike the straight arrow, we can't just stick the label in the middle of the shape when\n\t// we're working out the range. this is because as the label moves along the curve, the place\n\t// where the arrow intersects with label changes. instead, we have to stick the label center on\n\t// the `startOffset` (the start-most place where it can go), then find where it intersects with\n\t// the arc. because of the symmetry of the label rectangle, we can move the label to that new\n\t// center and take that as the start-most possible point.\n\tconst startIntersections = intersectArcPolygon(\n\t\tinfo.bodyArc.center,\n\t\tinfo.bodyArc.radius,\n\t\tstartOffsetAngle,\n\t\tendOffsetAngle,\n\t\tdirection,\n\t\tBox.FromCenter(startOffset, labelSize).corners\n\t)\n\n\tdbg.push(\n\t\tnew Polygon2d({\n\t\t\tpoints: Box.FromCenter(startOffset, labelSize).corners,\n\t\t\tdebugColor: 'lime',\n\t\t\tisFilled: false,\n\t\t\tignore: true,\n\t\t})\n\t)\n\n\tconst endIntersections = intersectArcPolygon(\n\t\tinfo.bodyArc.center,\n\t\tinfo.bodyArc.radius,\n\t\tstartOffsetAngle,\n\t\tendOffsetAngle,\n\t\tdirection,\n\t\tBox.FromCenter(endOffset, labelSize).corners\n\t)\n\n\tdbg.push(\n\t\tnew Polygon2d({\n\t\t\tpoints: Box.FromCenter(endOffset, labelSize).corners,\n\t\t\tdebugColor: 'lime',\n\t\t\tisFilled: false,\n\t\t\tignore: true,\n\t\t})\n\t)\n\tfor (const pt of [\n\t\t...(startIntersections ?? []),\n\t\t...(endIntersections ?? []),\n\t\tstartOffset,\n\t\tendOffset,\n\t]) {\n\t\tdbg.push(\n\t\t\tnew Circle2d({\n\t\t\t\tx: pt.x - 3,\n\t\t\t\ty: pt.y - 3,\n\t\t\t\tradius: 3,\n\t\t\t\tisFilled: false,\n\t\t\t\tdebugColor: 'magenta',\n\t\t\t\tignore: true,\n\t\t\t})\n\t\t)\n\t}\n\n\t// if we have one or more intersections (we shouldn't have more than two) then the one we need\n\t// is the one furthest from the arrow terminal\n\tconst startConstrained =\n\t\t(startIntersections && furthest(info.start.point, startIntersections)) ?? info.middle\n\tconst endConstrained =\n\t\t(endIntersections && furthest(info.end.point, endIntersections)) ?? info.middle\n\n\tconst startAngle = Vec.Angle(info.bodyArc.center, info.start.point)\n\tconst endAngle = Vec.Angle(info.bodyArc.center, info.end.point)\n\tconst constrainedStartAngle = Vec.Angle(info.bodyArc.center, startConstrained)\n\tconst constrainedEndAngle = Vec.Angle(info.bodyArc.center, endConstrained)\n\n\t// if the arc is small enough that there's no room for the label to move, we constrain it to the middle.\n\tif (\n\t\tangleDistance(startAngle, constrainedStartAngle, direction) >\n\t\tangleDistance(startAngle, constrainedEndAngle, direction)\n\t) {\n\t\treturn { start: 0.5, end: 0.5, dbg }\n\t}\n\n\t// now we can work out the range of possible label positions\n\tconst fullDistance = angleDistance(startAngle, endAngle, direction)\n\tconst start = angleDistance(startAngle, constrainedStartAngle, direction) / fullDistance\n\tconst end = angleDistance(startAngle, constrainedEndAngle, direction) / fullDistance\n\treturn { start, end, dbg }\n}\n\nexport function getArrowLabelPosition(editor: Editor, shape: TLArrowShape) {\n\tlet labelCenter\n\tconst debugGeom: Geometry2d[] = []\n\tconst info = getArrowInfo(editor, shape)!\n\n\tconst hasStartBinding = !!info.bindings.start\n\tconst hasEndBinding = !!info.bindings.end\n\tconst hasStartArrowhead = info.start.arrowhead !== 'none'\n\tconst hasEndArrowhead = info.end.arrowhead !== 'none'\n\tif (info.isStraight) {\n\t\tconst range = getStraightArrowLabelRange(editor, shape, info)\n\t\tlet clampedPosition = clamp(\n\t\t\tshape.props.labelPosition,\n\t\t\thasStartArrowhead || hasStartBinding ? range.start : 0,\n\t\t\thasEndArrowhead || hasEndBinding ? range.end : 1\n\t\t)\n\t\t// This makes the position snap in the middle.\n\t\tclampedPosition = clampedPosition >= 0.48 && clampedPosition <= 0.52 ? 0.5 : clampedPosition\n\t\tlabelCenter = Vec.Lrp(info.start.point, info.end.point, clampedPosition)\n\t} else {\n\t\tconst range = getCurvedArrowLabelRange(editor, shape, info)\n\t\tif (range.dbg) debugGeom.push(...range.dbg)\n\t\tlet clampedPosition = clamp(\n\t\t\tshape.props.labelPosition,\n\t\t\thasStartArrowhead || hasStartBinding ? range.start : 0,\n\t\t\thasEndArrowhead || hasEndBinding ? range.end : 1\n\t\t)\n\t\t// This makes the position snap in the middle.\n\t\tclampedPosition = clampedPosition >= 0.48 && clampedPosition <= 0.52 ? 0.5 : clampedPosition\n\t\tconst labelAngle = interpolateArcAngles(\n\t\t\tVec.Angle(info.bodyArc.center, info.start.point),\n\t\t\tVec.Angle(info.bodyArc.center, info.end.point),\n\t\t\tMath.sign(shape.props.bend),\n\t\t\tclampedPosition\n\t\t)\n\t\tlabelCenter = getPointOnCircle(info.bodyArc.center, info.bodyArc.radius, labelAngle)\n\t}\n\n\tconst labelSize = getArrowLabelSize(editor, shape)\n\n\treturn { box: Box.FromCenter(labelCenter, labelSize), debugGeom }\n}\n\nfunction intersectArcPolygon(\n\tcenter: VecLike,\n\tradius: number,\n\tangleStart: number,\n\tangleEnd: number,\n\tdirection: number,\n\tpolygon: VecLike[]\n) {\n\tconst intersections = intersectCirclePolygon(center, radius, polygon)\n\n\t// filter the circle intersections to just the ones from the arc\n\tconst fullArcDistance = angleDistance(angleStart, angleEnd, direction)\n\treturn intersections?.filter((pt) => {\n\t\tconst pDistance = angleDistance(angleStart, Vec.Angle(center, pt), direction)\n\t\treturn pDistance >= 0 && pDistance <= fullArcDistance\n\t})\n}\n\nfunction furthest(from: VecLike, candidates: VecLike[]): VecLike | null {\n\tlet furthest: VecLike | null = null\n\tlet furthestDist = -Infinity\n\n\tfor (const candidate of candidates) {\n\t\tconst dist = Vec.Dist2(from, candidate)\n\t\tif (dist > furthestDist) {\n\t\t\tfurthest = candidate\n\t\t\tfurthestDist = dist\n\t\t}\n\t}\n\n\treturn furthest\n}\n\n/**\n *\n * @param angleStart - The angle of the start of the arc\n * @param angleEnd - The angle of the end of the arc\n * @param direction - The direction of the arc (1 = counter-clockwise, -1 = clockwise)\n * @param t - A number between 0 and 1 representing the position along the arc\n * @returns\n */\nfunction interpolateArcAngles(angleStart: number, angleEnd: number, direction: number, t: number) {\n\tconst dist = angleDistance(angleStart, angleEnd, direction)\n\treturn angleStart + dist * t * direction * -1\n}\n\nexport function getArrowLabelFontSize(shape: TLArrowShape) {\n\treturn ARROW_LABEL_FONT_SIZES[shape.props.size] * shape.props.scale\n}\n"],
  "mappings": "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",
  "names": ["furthest"]
}
