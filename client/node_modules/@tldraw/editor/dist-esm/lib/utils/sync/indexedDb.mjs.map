{
  "version": 3,
  "sources": ["../../../../src/lib/utils/sync/indexedDb.ts"],
  "sourcesContent": ["import { RecordsDiff, SerializedSchema, SerializedStore } from '@tldraw/store'\nimport { TLRecord, TLStoreSchema } from '@tldraw/tlschema'\nimport { getFromLocalStorage, setInLocalStorage } from '@tldraw/utils'\nimport { IDBPDatabase, openDB } from 'idb'\nimport { TLSessionStateSnapshot } from '../../config/TLSessionStateSnapshot'\n\n// DO NOT CHANGE THESE WITHOUT ADDING MIGRATION LOGIC. DOING SO WOULD WIPE ALL EXISTING DATA.\nconst STORE_PREFIX = 'TLDRAW_DOCUMENT_v2'\nconst dbNameIndexKey = 'TLDRAW_DB_NAME_INDEX_v2'\n\nconst Table = {\n\tRecords: 'records',\n\tSchema: 'schema',\n\tSessionState: 'session_state',\n} as const\n\ntype StoreName = (typeof Table)[keyof typeof Table]\n\nasync function withDb<T>(storeId: string, cb: (db: IDBPDatabase<StoreName>) => Promise<T>) {\n\taddDbName(storeId)\n\tconst db = await openDB<StoreName>(storeId, 3, {\n\t\tupgrade(database) {\n\t\t\tif (!database.objectStoreNames.contains(Table.Records)) {\n\t\t\t\tdatabase.createObjectStore(Table.Records)\n\t\t\t}\n\t\t\tif (!database.objectStoreNames.contains(Table.Schema)) {\n\t\t\t\tdatabase.createObjectStore(Table.Schema)\n\t\t\t}\n\t\t\tif (!database.objectStoreNames.contains(Table.SessionState)) {\n\t\t\t\tdatabase.createObjectStore(Table.SessionState)\n\t\t\t}\n\t\t},\n\t})\n\ttry {\n\t\treturn await cb(db)\n\t} finally {\n\t\tdb.close()\n\t}\n}\n\ninterface LoadResult {\n\trecords: TLRecord[]\n\tschema?: SerializedSchema\n\tsessionStateSnapshot?: TLSessionStateSnapshot | null\n}\n\ninterface SessionStateSnapshotRow {\n\tid: string\n\tsnapshot: TLSessionStateSnapshot\n\tupdatedAt: number\n}\n\n/** @internal */\nexport async function loadDataFromStore({\n\tpersistenceKey,\n\tsessionId,\n\tdidCancel,\n}: {\n\tpersistenceKey: string\n\tsessionId?: string\n\tdidCancel?: () => boolean\n}): Promise<undefined | LoadResult> {\n\tconst storeId = STORE_PREFIX + persistenceKey\n\tif (!getAllIndexDbNames().includes(storeId)) return undefined\n\tawait pruneSessionState({ persistenceKey, didCancel })\n\treturn await withDb(storeId, async (db) => {\n\t\tif (didCancel?.()) return undefined\n\t\tconst tx = db.transaction([Table.Records, Table.Schema, Table.SessionState], 'readonly')\n\t\tconst recordsStore = tx.objectStore(Table.Records)\n\t\tconst schemaStore = tx.objectStore(Table.Schema)\n\t\tconst sessionStateStore = tx.objectStore(Table.SessionState)\n\t\tlet sessionStateSnapshot = sessionId\n\t\t\t? ((await sessionStateStore.get(sessionId)) as SessionStateSnapshotRow | undefined)?.snapshot\n\t\t\t: null\n\t\tif (!sessionStateSnapshot) {\n\t\t\t// get the most recent session state\n\t\t\tconst all = (await sessionStateStore.getAll()) as SessionStateSnapshotRow[]\n\t\t\tsessionStateSnapshot = all.sort((a, b) => a.updatedAt - b.updatedAt).pop()?.snapshot\n\t\t}\n\t\tconst result = {\n\t\t\trecords: await recordsStore.getAll(),\n\t\t\tschema: await schemaStore.get(Table.Schema),\n\t\t\tsessionStateSnapshot,\n\t\t} satisfies LoadResult\n\t\tif (didCancel?.()) {\n\t\t\ttx.abort()\n\t\t\treturn undefined\n\t\t}\n\t\tawait tx.done\n\t\treturn result\n\t})\n}\n\n/** @internal */\nexport async function storeChangesInIndexedDb({\n\tpersistenceKey,\n\tschema,\n\tchanges,\n\tsessionId,\n\tsessionStateSnapshot,\n\tdidCancel,\n}: {\n\tpersistenceKey: string\n\tschema: TLStoreSchema\n\tchanges: RecordsDiff<any>\n\tsessionId?: string | null\n\tsessionStateSnapshot?: TLSessionStateSnapshot | null\n\tdidCancel?: () => boolean\n}) {\n\tconst storeId = STORE_PREFIX + persistenceKey\n\tawait withDb(storeId, async (db) => {\n\t\tconst tx = db.transaction([Table.Records, Table.Schema, Table.SessionState], 'readwrite')\n\t\tconst recordsStore = tx.objectStore(Table.Records)\n\t\tconst schemaStore = tx.objectStore(Table.Schema)\n\t\tconst sessionStateStore = tx.objectStore(Table.SessionState)\n\n\t\tfor (const [id, record] of Object.entries(changes.added)) {\n\t\t\tawait recordsStore.put(record, id)\n\t\t}\n\n\t\tfor (const [_prev, updated] of Object.values(changes.updated)) {\n\t\t\tawait recordsStore.put(updated, updated.id)\n\t\t}\n\n\t\tfor (const id of Object.keys(changes.removed)) {\n\t\t\tawait recordsStore.delete(id)\n\t\t}\n\n\t\tschemaStore.put(schema.serialize(), Table.Schema)\n\t\tif (sessionStateSnapshot && sessionId) {\n\t\t\tsessionStateStore.put(\n\t\t\t\t{\n\t\t\t\t\tsnapshot: sessionStateSnapshot,\n\t\t\t\t\tupdatedAt: Date.now(),\n\t\t\t\t\tid: sessionId,\n\t\t\t\t} satisfies SessionStateSnapshotRow,\n\t\t\t\tsessionId\n\t\t\t)\n\t\t} else if (sessionStateSnapshot || sessionId) {\n\t\t\tconsole.error('sessionStateSnapshot and instanceId must be provided together')\n\t\t}\n\n\t\tif (didCancel?.()) return tx.abort()\n\n\t\tawait tx.done\n\t})\n}\n\n/** @internal */\nexport async function storeSnapshotInIndexedDb({\n\tpersistenceKey,\n\tschema,\n\tsnapshot,\n\tsessionId,\n\tsessionStateSnapshot,\n\tdidCancel,\n}: {\n\tpersistenceKey: string\n\tschema: TLStoreSchema\n\tsnapshot: SerializedStore<any>\n\tsessionId?: string | null\n\tsessionStateSnapshot?: TLSessionStateSnapshot | null\n\tdidCancel?: () => boolean\n}) {\n\tconst storeId = STORE_PREFIX + persistenceKey\n\tawait withDb(storeId, async (db) => {\n\t\tconst tx = db.transaction([Table.Records, Table.Schema, Table.SessionState], 'readwrite')\n\t\tconst recordsStore = tx.objectStore(Table.Records)\n\t\tconst schemaStore = tx.objectStore(Table.Schema)\n\t\tconst sessionStateStore = tx.objectStore(Table.SessionState)\n\n\t\tawait recordsStore.clear()\n\n\t\tfor (const [id, record] of Object.entries(snapshot)) {\n\t\t\tawait recordsStore.put(record, id)\n\t\t}\n\n\t\tschemaStore.put(schema.serialize(), Table.Schema)\n\n\t\tif (sessionStateSnapshot && sessionId) {\n\t\t\tsessionStateStore.put(\n\t\t\t\t{\n\t\t\t\t\tsnapshot: sessionStateSnapshot,\n\t\t\t\t\tupdatedAt: Date.now(),\n\t\t\t\t\tid: sessionId,\n\t\t\t\t} satisfies SessionStateSnapshotRow,\n\t\t\t\tsessionId\n\t\t\t)\n\t\t} else if (sessionStateSnapshot || sessionId) {\n\t\t\tconsole.error('sessionStateSnapshot and instanceId must be provided together')\n\t\t}\n\n\t\tif (didCancel?.()) return tx.abort()\n\n\t\tawait tx.done\n\t})\n}\n\nasync function pruneSessionState({\n\tpersistenceKey,\n\tdidCancel,\n}: {\n\tpersistenceKey: string\n\tdidCancel?: () => boolean\n}) {\n\tawait withDb(STORE_PREFIX + persistenceKey, async (db) => {\n\t\tconst tx = db.transaction([Table.SessionState], 'readwrite')\n\t\tconst sessionStateStore = tx.objectStore(Table.SessionState)\n\t\tconst all = (await sessionStateStore.getAll()).sort((a, b) => a.updatedAt - b.updatedAt)\n\t\tif (all.length < 10) {\n\t\t\tawait tx.done\n\t\t\treturn\n\t\t}\n\t\tconst toDelete = all.slice(0, all.length - 10)\n\t\tfor (const { id } of toDelete) {\n\t\t\tawait sessionStateStore.delete(id)\n\t\t}\n\t\tif (didCancel?.()) return tx.abort()\n\t\tawait tx.done\n\t})\n}\n\n/** @internal */\nexport function getAllIndexDbNames(): string[] {\n\tconst result = JSON.parse(getFromLocalStorage(dbNameIndexKey) || '[]') ?? []\n\tif (!Array.isArray(result)) {\n\t\treturn []\n\t}\n\treturn result\n}\n\nfunction addDbName(name: string) {\n\tconst all = new Set(getAllIndexDbNames())\n\tall.add(name)\n\tsetInLocalStorage(dbNameIndexKey, JSON.stringify([...all]))\n}\n"],
  "mappings": "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",
  "names": []
}
