{
  "version": 3,
  "sources": ["../../../../src/lib/reordering/dgreensp/dgreensp.ts"],
  "sourcesContent": ["// Adapted from https://observablehq.com/@dgreensp/implementing-fractional-indexing\n// by @dgreensp (twitter @DavidLG)\n\nimport { IndexKey } from '../IndexKey'\n\nconst DIGITS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\nexport const INTEGER_ZERO = 'a0' as IndexKey\nconst SMALLEST_INTEGER = 'A00000000000000000000000000'\n\n/**\n * Get the length of an integer.\n *\n * @param head - The integer to use.\n */\nfunction getIntegerLength(head: string): number {\n\tif (head >= 'a' && head <= 'z') {\n\t\treturn head.charCodeAt(0) - 'a'.charCodeAt(0) + 2\n\t} else if (head >= 'A' && head <= 'Z') {\n\t\treturn 'Z'.charCodeAt(0) - head.charCodeAt(0) + 2\n\t} else {\n\t\tthrow new Error('Invalid index key head: ' + head)\n\t}\n}\n\n/**\n * Validate an integer.\n *\n * @param int - The integer to use.\n */\nfunction validateInteger(int: string): asserts int is string {\n\tif (int.length !== getIntegerLength(int.charAt(0))) {\n\t\tthrow new Error('invalid integer part of index key: ' + int)\n\t}\n}\n\nfunction isNotUndefined(n: string | undefined): asserts n is string {\n\tif (n === undefined) throw Error('n is undefined')\n}\n\n/**\n * Increment an integer.\n *\n * @param x - The integer to increment\n *\n * @internal\n */\nfunction incrementInteger(x: string): string | undefined {\n\tvalidateInteger(x)\n\tconst [head, ...digs] = x.split('')\n\tlet carry = true\n\tfor (let i = digs.length - 1; carry && i >= 0; i--) {\n\t\tconst d = DIGITS.indexOf(digs[i]) + 1\n\t\tif (d === DIGITS.length) {\n\t\t\tdigs[i] = '0'\n\t\t} else {\n\t\t\tdigs[i] = DIGITS.charAt(d)\n\t\t\tcarry = false\n\t\t}\n\t}\n\tif (carry) {\n\t\tif (head === 'Z') return 'a0'\n\t\tif (head === 'z') return undefined\n\t\tconst h = String.fromCharCode(head.charCodeAt(0) + 1)\n\t\tif (h > 'a') {\n\t\t\tdigs.push('0')\n\t\t} else {\n\t\t\tdigs.pop()\n\t\t}\n\t\treturn h + digs.join('')\n\t} else {\n\t\treturn head + digs.join('')\n\t}\n}\n\n/**\n * Decrement an integer.\n *\n * @param x - The integer to decrement\n *\n * @internal\n */\nfunction decrementInteger(x: string): string | undefined {\n\tvalidateInteger(x)\n\tconst [head, ...digs] = x.split('')\n\tlet borrow = true\n\tfor (let i = digs.length - 1; borrow && i >= 0; i--) {\n\t\tconst d = DIGITS.indexOf(digs[i]) - 1\n\t\tif (d === -1) {\n\t\t\tdigs[i] = DIGITS.slice(-1)\n\t\t} else {\n\t\t\tdigs[i] = DIGITS.charAt(d)\n\t\t\tborrow = false\n\t\t}\n\t}\n\tif (borrow) {\n\t\tif (head === 'a') return 'Z' + DIGITS.slice(-1)\n\t\tif (head === 'A') return undefined\n\t\tconst h = String.fromCharCode(head.charCodeAt(0) - 1)\n\t\tif (h < 'Z') {\n\t\t\tdigs.push(DIGITS.slice(-1))\n\t\t} else {\n\t\t\tdigs.pop()\n\t\t}\n\t\treturn h + digs.join('')\n\t} else {\n\t\treturn head + digs.join('')\n\t}\n}\n\n/**\n * Get the midpoint between two indexs.\n *\n * @param a - The start index.\n * @param b - The end index.\n *\n * @internal\n */\nfunction midpoint(a: string, b: string | undefined): string {\n\tif (b !== undefined && a >= b) {\n\t\tthrow new Error(a + ' >= ' + b)\n\t}\n\tif (a.slice(-1) === '0' || (b && b.slice(-1) === '0')) {\n\t\tthrow new Error('trailing zero')\n\t}\n\tif (b) {\n\t\tlet n = 0\n\t\twhile ((a.charAt(n) || '0') === b.charAt(n)) {\n\t\t\tn++\n\t\t}\n\t\tif (n > 0) {\n\t\t\treturn b.slice(0, n) + midpoint(a.slice(n), b.slice(n))\n\t\t}\n\t}\n\tconst digitA = a ? DIGITS.indexOf(a.charAt(0)) : 0\n\tconst digitB = b !== undefined ? DIGITS.indexOf(b.charAt(0)) : DIGITS.length\n\tif (digitB - digitA > 1) {\n\t\tconst midDigit = Math.round(0.5 * (digitA + digitB))\n\t\treturn DIGITS.charAt(midDigit)\n\t} else {\n\t\tif (b && b.length > 1) {\n\t\t\treturn b.slice(0, 1)\n\t\t} else {\n\t\t\treturn DIGITS.charAt(digitA) + midpoint(a.slice(1), undefined)\n\t\t}\n\t}\n}\n\n/**\n * Get the integer part of an index.\n *\n * @param index - The index to use.\n */\nfunction getIntegerPart(index: string): string {\n\tconst integerPartLength = getIntegerLength(index.charAt(0))\n\tif (integerPartLength > index.length) {\n\t\tthrow new Error('invalid index: ' + index)\n\t}\n\treturn index.slice(0, integerPartLength)\n}\n\n/**\n * Validate an index.\n *\n * @param x - The index to validate.\n */\nexport function validateOrder(index: string): asserts index is string {\n\tif (index === SMALLEST_INTEGER) {\n\t\tthrow new Error('invalid index: ' + index)\n\t}\n\t// getIntegerPart will throw if the first character is bad,\n\t// or the key is too short.  we'd call it to check these things\n\t// even if we didn't need the result\n\tconst i = getIntegerPart(index)\n\tconst f = index.slice(i.length)\n\tif (f.slice(-1) === '0') {\n\t\tthrow new Error('invalid index: ' + index)\n\t}\n}\n\n/**\n * Generate an index key at the midpoint between a start and end.\n *\n * @param a - The start index key string.\n * @param b - The end index key string, greater than A.\n */\nfunction generateKeyBetween(a: IndexKey | undefined, b: IndexKey | undefined): IndexKey {\n\tif (a !== undefined) validateOrder(a)\n\tif (b !== undefined) validateOrder(b)\n\tif (a !== undefined && b !== undefined && a >= b) {\n\t\tthrow new Error(a + ' >= ' + b)\n\t}\n\tif (a === undefined && b === undefined) {\n\t\treturn INTEGER_ZERO\n\t}\n\tif (a === undefined) {\n\t\tif (b === undefined) throw Error('b is undefined')\n\t\tconst ib = getIntegerPart(b)\n\t\tconst fb = b.slice(ib.length)\n\t\tif (ib === SMALLEST_INTEGER) {\n\t\t\treturn (ib + midpoint('', fb)) as IndexKey\n\t\t}\n\t\tif (ib < b) {\n\t\t\treturn ib as IndexKey\n\t\t}\n\t\tconst ibl = decrementInteger(ib)\n\t\tisNotUndefined(ibl)\n\t\treturn ibl as IndexKey\n\t}\n\tif (b === undefined) {\n\t\tconst ia = getIntegerPart(a)\n\t\tconst fa = a.slice(ia.length)\n\t\tconst i = incrementInteger(ia)\n\t\treturn (i === undefined ? ia + midpoint(fa, undefined) : i) as IndexKey\n\t}\n\tconst ia = getIntegerPart(a)\n\tconst fa = a.slice(ia.length)\n\tconst ib = getIntegerPart(b)\n\tconst fb = b.slice(ib.length)\n\tif (ia === ib) {\n\t\treturn (ia + midpoint(fa, fb)) as IndexKey\n\t}\n\tconst i = incrementInteger(ia)\n\tisNotUndefined(i)\n\treturn (i < b ? i : ia + midpoint(fa, undefined)) as IndexKey\n}\n\n/**\n * Generate N number of index keys between the start and end index.\n *\n * @param a - The start index key string.\n * @param b - The end index key, greater than A string.\n * @param n - The number of index keys to generate.\n */\nexport function generateNKeysBetween(\n\ta: IndexKey | undefined,\n\tb: IndexKey | undefined,\n\tn: number\n): IndexKey[] {\n\tif (n === 0) return []\n\tif (n === 1) return [generateKeyBetween(a, b)]\n\tif (b === undefined) {\n\t\tlet c = generateKeyBetween(a, b)\n\t\tconst result = [c]\n\t\tfor (let i = 0; i < n - 1; i++) {\n\t\t\tc = generateKeyBetween(c, b)\n\t\t\tresult.push(c)\n\t\t}\n\t\treturn result\n\t}\n\tif (a === undefined) {\n\t\tlet c = generateKeyBetween(a, b)\n\t\tconst result = [c]\n\t\tfor (let i = 0; i < n - 1; i++) {\n\t\t\tc = generateKeyBetween(a, c)\n\t\t\tresult.push(c)\n\t\t}\n\t\tresult.reverse()\n\t\treturn result\n\t}\n\tconst mid = Math.floor(n / 2)\n\tconst c = generateKeyBetween(a, b)\n\treturn [...generateNKeysBetween(a, c, mid), c, ...generateNKeysBetween(c, b, n - mid - 1)]\n}\n"],
  "mappings": "AAKA,MAAM,SAAS;AACR,MAAM,eAAe;AAC5B,MAAM,mBAAmB;AAOzB,SAAS,iBAAiB,MAAsB;AAC/C,MAAI,QAAQ,OAAO,QAAQ,KAAK;AAC/B,WAAO,KAAK,WAAW,CAAC,IAAI,IAAI,WAAW,CAAC,IAAI;AAAA,EACjD,WAAW,QAAQ,OAAO,QAAQ,KAAK;AACtC,WAAO,IAAI,WAAW,CAAC,IAAI,KAAK,WAAW,CAAC,IAAI;AAAA,EACjD,OAAO;AACN,UAAM,IAAI,MAAM,6BAA6B,IAAI;AAAA,EAClD;AACD;AAOA,SAAS,gBAAgB,KAAoC;AAC5D,MAAI,IAAI,WAAW,iBAAiB,IAAI,OAAO,CAAC,CAAC,GAAG;AACnD,UAAM,IAAI,MAAM,wCAAwC,GAAG;AAAA,EAC5D;AACD;AAEA,SAAS,eAAe,GAA4C;AACnE,MAAI,MAAM;AAAW,UAAM,MAAM,gBAAgB;AAClD;AASA,SAAS,iBAAiB,GAA+B;AACxD,kBAAgB,CAAC;AACjB,QAAM,CAAC,MAAM,GAAG,IAAI,IAAI,EAAE,MAAM,EAAE;AAClC,MAAI,QAAQ;AACZ,WAAS,IAAI,KAAK,SAAS,GAAG,SAAS,KAAK,GAAG,KAAK;AACnD,UAAM,IAAI,OAAO,QAAQ,KAAK,CAAC,CAAC,IAAI;AACpC,QAAI,MAAM,OAAO,QAAQ;AACxB,WAAK,CAAC,IAAI;AAAA,IACX,OAAO;AACN,WAAK,CAAC,IAAI,OAAO,OAAO,CAAC;AACzB,cAAQ;AAAA,IACT;AAAA,EACD;AACA,MAAI,OAAO;AACV,QAAI,SAAS;AAAK,aAAO;AACzB,QAAI,SAAS;AAAK,aAAO;AACzB,UAAM,IAAI,OAAO,aAAa,KAAK,WAAW,CAAC,IAAI,CAAC;AACpD,QAAI,IAAI,KAAK;AACZ,WAAK,KAAK,GAAG;AAAA,IACd,OAAO;AACN,WAAK,IAAI;AAAA,IACV;AACA,WAAO,IAAI,KAAK,KAAK,EAAE;AAAA,EACxB,OAAO;AACN,WAAO,OAAO,KAAK,KAAK,EAAE;AAAA,EAC3B;AACD;AASA,SAAS,iBAAiB,GAA+B;AACxD,kBAAgB,CAAC;AACjB,QAAM,CAAC,MAAM,GAAG,IAAI,IAAI,EAAE,MAAM,EAAE;AAClC,MAAI,SAAS;AACb,WAAS,IAAI,KAAK,SAAS,GAAG,UAAU,KAAK,GAAG,KAAK;AACpD,UAAM,IAAI,OAAO,QAAQ,KAAK,CAAC,CAAC,IAAI;AACpC,QAAI,MAAM,IAAI;AACb,WAAK,CAAC,IAAI,OAAO,MAAM,EAAE;AAAA,IAC1B,OAAO;AACN,WAAK,CAAC,IAAI,OAAO,OAAO,CAAC;AACzB,eAAS;AAAA,IACV;AAAA,EACD;AACA,MAAI,QAAQ;AACX,QAAI,SAAS;AAAK,aAAO,MAAM,OAAO,MAAM,EAAE;AAC9C,QAAI,SAAS;AAAK,aAAO;AACzB,UAAM,IAAI,OAAO,aAAa,KAAK,WAAW,CAAC,IAAI,CAAC;AACpD,QAAI,IAAI,KAAK;AACZ,WAAK,KAAK,OAAO,MAAM,EAAE,CAAC;AAAA,IAC3B,OAAO;AACN,WAAK,IAAI;AAAA,IACV;AACA,WAAO,IAAI,KAAK,KAAK,EAAE;AAAA,EACxB,OAAO;AACN,WAAO,OAAO,KAAK,KAAK,EAAE;AAAA,EAC3B;AACD;AAUA,SAAS,SAAS,GAAW,GAA+B;AAC3D,MAAI,MAAM,UAAa,KAAK,GAAG;AAC9B,UAAM,IAAI,MAAM,IAAI,SAAS,CAAC;AAAA,EAC/B;AACA,MAAI,EAAE,MAAM,EAAE,MAAM,OAAQ,KAAK,EAAE,MAAM,EAAE,MAAM,KAAM;AACtD,UAAM,IAAI,MAAM,eAAe;AAAA,EAChC;AACA,MAAI,GAAG;AACN,QAAI,IAAI;AACR,YAAQ,EAAE,OAAO,CAAC,KAAK,SAAS,EAAE,OAAO,CAAC,GAAG;AAC5C;AAAA,IACD;AACA,QAAI,IAAI,GAAG;AACV,aAAO,EAAE,MAAM,GAAG,CAAC,IAAI,SAAS,EAAE,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;AAAA,IACvD;AAAA,EACD;AACA,QAAM,SAAS,IAAI,OAAO,QAAQ,EAAE,OAAO,CAAC,CAAC,IAAI;AACjD,QAAM,SAAS,MAAM,SAAY,OAAO,QAAQ,EAAE,OAAO,CAAC,CAAC,IAAI,OAAO;AACtE,MAAI,SAAS,SAAS,GAAG;AACxB,UAAM,WAAW,KAAK,MAAM,OAAO,SAAS,OAAO;AACnD,WAAO,OAAO,OAAO,QAAQ;AAAA,EAC9B,OAAO;AACN,QAAI,KAAK,EAAE,SAAS,GAAG;AACtB,aAAO,EAAE,MAAM,GAAG,CAAC;AAAA,IACpB,OAAO;AACN,aAAO,OAAO,OAAO,MAAM,IAAI,SAAS,EAAE,MAAM,CAAC,GAAG,MAAS;AAAA,IAC9D;AAAA,EACD;AACD;AAOA,SAAS,eAAe,OAAuB;AAC9C,QAAM,oBAAoB,iBAAiB,MAAM,OAAO,CAAC,CAAC;AAC1D,MAAI,oBAAoB,MAAM,QAAQ;AACrC,UAAM,IAAI,MAAM,oBAAoB,KAAK;AAAA,EAC1C;AACA,SAAO,MAAM,MAAM,GAAG,iBAAiB;AACxC;AAOO,SAAS,cAAc,OAAwC;AACrE,MAAI,UAAU,kBAAkB;AAC/B,UAAM,IAAI,MAAM,oBAAoB,KAAK;AAAA,EAC1C;AAIA,QAAM,IAAI,eAAe,KAAK;AAC9B,QAAM,IAAI,MAAM,MAAM,EAAE,MAAM;AAC9B,MAAI,EAAE,MAAM,EAAE,MAAM,KAAK;AACxB,UAAM,IAAI,MAAM,oBAAoB,KAAK;AAAA,EAC1C;AACD;AAQA,SAAS,mBAAmB,GAAyB,GAAmC;AACvF,MAAI,MAAM;AAAW,kBAAc,CAAC;AACpC,MAAI,MAAM;AAAW,kBAAc,CAAC;AACpC,MAAI,MAAM,UAAa,MAAM,UAAa,KAAK,GAAG;AACjD,UAAM,IAAI,MAAM,IAAI,SAAS,CAAC;AAAA,EAC/B;AACA,MAAI,MAAM,UAAa,MAAM,QAAW;AACvC,WAAO;AAAA,EACR;AACA,MAAI,MAAM,QAAW;AACpB,QAAI,MAAM;AAAW,YAAM,MAAM,gBAAgB;AACjD,UAAMA,MAAK,eAAe,CAAC;AAC3B,UAAMC,MAAK,EAAE,MAAMD,IAAG,MAAM;AAC5B,QAAIA,QAAO,kBAAkB;AAC5B,aAAQA,MAAK,SAAS,IAAIC,GAAE;AAAA,IAC7B;AACA,QAAID,MAAK,GAAG;AACX,aAAOA;AAAA,IACR;AACA,UAAM,MAAM,iBAAiBA,GAAE;AAC/B,mBAAe,GAAG;AAClB,WAAO;AAAA,EACR;AACA,MAAI,MAAM,QAAW;AACpB,UAAME,MAAK,eAAe,CAAC;AAC3B,UAAMC,MAAK,EAAE,MAAMD,IAAG,MAAM;AAC5B,UAAME,KAAI,iBAAiBF,GAAE;AAC7B,WAAQE,OAAM,SAAYF,MAAK,SAASC,KAAI,MAAS,IAAIC;AAAA,EAC1D;AACA,QAAM,KAAK,eAAe,CAAC;AAC3B,QAAM,KAAK,EAAE,MAAM,GAAG,MAAM;AAC5B,QAAM,KAAK,eAAe,CAAC;AAC3B,QAAM,KAAK,EAAE,MAAM,GAAG,MAAM;AAC5B,MAAI,OAAO,IAAI;AACd,WAAQ,KAAK,SAAS,IAAI,EAAE;AAAA,EAC7B;AACA,QAAM,IAAI,iBAAiB,EAAE;AAC7B,iBAAe,CAAC;AAChB,SAAQ,IAAI,IAAI,IAAI,KAAK,SAAS,IAAI,MAAS;AAChD;AASO,SAAS,qBACf,GACA,GACA,GACa;AACb,MAAI,MAAM;AAAG,WAAO,CAAC;AACrB,MAAI,MAAM;AAAG,WAAO,CAAC,mBAAmB,GAAG,CAAC,CAAC;AAC7C,MAAI,MAAM,QAAW;AACpB,QAAIC,KAAI,mBAAmB,GAAG,CAAC;AAC/B,UAAM,SAAS,CAACA,EAAC;AACjB,aAAS,IAAI,GAAG,IAAI,IAAI,GAAG,KAAK;AAC/B,MAAAA,KAAI,mBAAmBA,IAAG,CAAC;AAC3B,aAAO,KAAKA,EAAC;AAAA,IACd;AACA,WAAO;AAAA,EACR;AACA,MAAI,MAAM,QAAW;AACpB,QAAIA,KAAI,mBAAmB,GAAG,CAAC;AAC/B,UAAM,SAAS,CAACA,EAAC;AACjB,aAAS,IAAI,GAAG,IAAI,IAAI,GAAG,KAAK;AAC/B,MAAAA,KAAI,mBAAmB,GAAGA,EAAC;AAC3B,aAAO,KAAKA,EAAC;AAAA,IACd;AACA,WAAO,QAAQ;AACf,WAAO;AAAA,EACR;AACA,QAAM,MAAM,KAAK,MAAM,IAAI,CAAC;AAC5B,QAAM,IAAI,mBAAmB,GAAG,CAAC;AACjC,SAAO,CAAC,GAAG,qBAAqB,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,qBAAqB,GAAG,GAAG,IAAI,MAAM,CAAC,CAAC;AAC1F;",
  "names": ["ib", "fb", "ia", "fa", "i", "c"]
}
